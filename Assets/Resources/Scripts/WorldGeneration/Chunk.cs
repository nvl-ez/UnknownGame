using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshCollider))]
public class Chunk : MonoBehaviour
{
    public NoiseGenerator noiseGenerator;
    public ComputeShader MarchingShader;

    MeshRenderer meshRenderer;
    Mesh _mesh;
    public int LOD = 4;
    float[] _weights = null;

    //Buffers for marching cubes
    ComputeBuffer _trianglesBuffer; //Contains all the triangles generated by the algorithm
    ComputeBuffer _trianglesCountBuffer; //Counts how many triangles will be generated
    ComputeBuffer _weightsBuffer; //Will contain the noise values in the GPU
    ComputeBuffer _weightsCountBuffer;

    MeshFilter meshFilter;
    MeshCollider meshCollider;

    public void Awake() {
        gameObject.layer = LayerMask.NameToLayer("Terrain");
        transform.tag = "Terrain";
        transform.name = transform.position.ToString();

        //Get the marching cubes algorithm and the object that generates the noise
        MarchingShader = Resources.Load<ComputeShader>("Scripts/WorldGeneration/Shaders/MarchingCubesCompute");
        noiseGenerator = GameObject.FindFirstObjectByType<NoiseGenerator>();

        meshFilter = gameObject.GetComponent<MeshFilter>();
        meshCollider = gameObject.GetComponent<MeshCollider>();
        meshRenderer = gameObject.GetComponent<MeshRenderer>();

        Create();
    }

    struct Triangle {
        public Vector3 a;
        public Vector3 b;
        public Vector3 c;

        public static int SizeOf => sizeof(float) * 3 * 3;
    }

    public void Create() {
        CreateBuffers();
        if (_weights == null) { //Generate the noise only once to avoid overwritting when changing lods
            _weights = noiseGenerator.GetNoise(GridMetrics.LastLod, transform.position);
        }
        _mesh = new Mesh();

        UpdateMesh();

        ReleaseBuffers();
    }

    public void OnValidate() {
        if(_mesh != null && Application.isPlaying) Create();

    }

    void CreateBuffers() {
        //Maximum 5 triangles per mesh, append means it is like a list instead of an array
        _trianglesBuffer = new ComputeBuffer(5 * (GridMetrics.PointsPerChunk(LOD) * GridMetrics.PointsPerChunk(LOD) * GridMetrics.PointsPerChunk(LOD)), Triangle.SizeOf, ComputeBufferType.Append);
        //single integer
        _trianglesCountBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);
        //conatains a float for each point
        _weightsBuffer = new ComputeBuffer(GridMetrics.PointsPerChunk(GridMetrics.LastLod) * GridMetrics.PointsPerChunk(GridMetrics.LastLod) * GridMetrics.PointsPerChunk(GridMetrics.LastLod), sizeof(float));
    }

    void ReleaseBuffers() {
        _trianglesBuffer.Release();
        _trianglesCountBuffer.Release();
        _weightsBuffer.Release();
    }

    //Will link the buffers on the GPU and make the mesh
    Mesh ConstructMesh() {
        int kernel = MarchingShader.FindKernel("March");

        MarchingShader.SetBuffer(kernel, "_Triangles", _trianglesBuffer);
        MarchingShader.SetBuffer(kernel, "_Weights", _weightsBuffer);

        float lodScaleFactor = ((float)GridMetrics.PointsPerChunk(GridMetrics.LastLod) + 1) / (float)GridMetrics.PointsPerChunk(LOD);

        MarchingShader.SetFloat("_LodScaleFactor", lodScaleFactor);
        MarchingShader.SetInt("_ChunkSize", GridMetrics.PointsPerChunk(GridMetrics.LastLod));
        MarchingShader.SetFloat("_IsoLevel", .5f);
        MarchingShader.SetInt("_Scale", GridMetrics.Scale);
        MarchingShader.SetInt("_LODSize", GridMetrics.PointsPerChunk(LOD));

        //Set the value of weights and the counter to 0
        _weightsBuffer.SetData(_weights);
        _trianglesBuffer.SetCounterValue(0);

        //Initialize the shader
        MarchingShader.Dispatch(kernel,
            GridMetrics.ThreadGroups(LOD),
            GridMetrics.ThreadGroups(LOD),
            GridMetrics.ThreadGroups(LOD));

        //Obtain the triangles
        Triangle[] triangles = new Triangle[ReadTriangleCount()];
        _trianglesBuffer.GetData(triangles);

        return CreateMeshFromTriangles(triangles);
    }

    //Gets the ammount of triangles generated
    int ReadTriangleCount() {
        int[] triCount = { 0 };
        ComputeBuffer.CopyCount(_trianglesBuffer, _trianglesCountBuffer, 0);
        _trianglesCountBuffer.GetData(triCount);
        return triCount[0];
    }

    /* FOR FLAT SHADING
    Mesh CreateMeshFromTriangles(Triangle[] triangles) {
        Vector3[] verts = new Vector3[triangles.Length * 3];
        int[] tris = new int[triangles.Length * 3];

        //Obtain the vertices and the triangles
        for (int i = 0; i < triangles.Length; i++) {
            int startIndex = i * 3;
            verts[startIndex] = triangles[i].a;
            verts[startIndex + 1] = triangles[i].b;
            verts[startIndex + 2] = triangles[i].c;
            tris[startIndex] = startIndex;
            tris[startIndex + 1] = startIndex + 1;
            tris[startIndex + 2] = startIndex + 2;
        }

        //Create the actual Mesh
        _mesh.Clear();
        _mesh.vertices = verts;
        _mesh.triangles = tris;
        _mesh.RecalculateNormals();
        return _mesh;
    }*/

    //FOR SMOOTH SHADING
    Mesh CreateMeshFromTriangles(Triangle[] triangles) {
        List<Vector3> verts = new List<Vector3>();
        List<int> tris = new List<int>();
        Dictionary<Vector3, int> vertexDictionary = new Dictionary<Vector3, int>();

        // Loop through each triangle
        for (int t = 0; t < triangles.Length; t++) {
            int[] triangleIndices = new int[3];
            Vector3[] triangleVertices = new Vector3[] { triangles[t].a, triangles[t].b, triangles[t].c };

            // Loop through each vertex in the triangle
            for (int i = 0; i < triangleVertices.Length; i++) {
                Vector3 vertex = triangleVertices[i];

                // Check if the vertex exists in the dictionary
                if (!vertexDictionary.TryGetValue(vertex, out int vertexIndex)) {
                    // Vertex does not exist, add it to the list and dictionary
                    verts.Add(vertex);
                    vertexIndex = verts.Count - 1;
                    vertexDictionary.Add(vertex, vertexIndex);
                }

                // Add the index of the vertex to the triangle's indices
                triangleIndices[i] = vertexIndex;
            }

            // Add the triangle's indices to the tris list
            tris.AddRange(triangleIndices);
        }

        // Create the actual Mesh
        _mesh.Clear();
        _mesh.vertices = verts.ToArray();
        _mesh.triangles = tris.ToArray();
        _mesh.RecalculateNormals();
        return _mesh;
    }

    //Will assign the new created mesh to the visual mesh and the collision mesh
    void UpdateMesh() {
        Mesh mesh = ConstructMesh();
        meshFilter.sharedMesh = mesh;
        meshCollider.sharedMesh = mesh;
    }

    //Allows us to change the values of the weights
    public void EditWeights(Vector3 hitPosition, float brushSize, bool add) {
        CreateBuffers();

        //Obtain the shader "program" that will be used
        int kernel = MarchingShader.FindKernel("UpdateWeights");

        //Set the current weights 
        _weightsBuffer.SetData(_weights);
        MarchingShader.SetBuffer(kernel, "_Weights", _weightsBuffer);

        MarchingShader.SetInt("_ChunkSize", GridMetrics.PointsPerChunk(GridMetrics.LastLod));
        MarchingShader.SetVector("_HitPosition", hitPosition);
        MarchingShader.SetFloat("_BrushSize", brushSize);
        MarchingShader.SetFloat("_TerraformStrength", add ? 1000f : -1000f); //Select if terrain will be added or substracted
        MarchingShader.SetInt("_Scale", GridMetrics.Scale);

        MarchingShader.Dispatch(kernel,
            GridMetrics.ThreadGroups(GridMetrics.LastLod),
            GridMetrics.ThreadGroups(GridMetrics.LastLod),
            GridMetrics.ThreadGroups(GridMetrics.LastLod));

        _weightsBuffer.GetData(_weights);

        UpdateMesh();

        ReleaseBuffers();
    }
}
